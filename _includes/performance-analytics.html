<!--
  Core Web Vitals & Performance Analytics
  Real User Monitoring (RUM) for blog performance optimization
  v1.0 - Created 2025-08-04
-->

<script>
(function() {
  'use strict';
  
  // Performance monitoring configuration
  const PERF_CONFIG = {
    // Core Web Vitals thresholds
    thresholds: {
      lcp: { good: 2500, needs_improvement: 4000 }, // Largest Contentful Paint
      fid: { good: 100, needs_improvement: 300 },   // First Input Delay  
      cls: { good: 0.1, needs_improvement: 0.25 },  // Cumulative Layout Shift
      fcp: { good: 1800, needs_improvement: 3000 }, // First Contentful Paint
      ttfb: { good: 800, needs_improvement: 1800 }  // Time to First Byte
    },
    
    // Sampling rate (0.1 = 10% of users)
    sampling_rate: 1.0, // 100% for development, reduce in production
    
    // Reporting configuration
    batch_size: 10,      // Number of metrics to batch before sending
    report_interval: 30000, // Report every 30 seconds
    
    // Device categorization thresholds
    device_memory_threshold: 4, // GB
    connection_speed_threshold: 1.5 // Mbps
  };
  
  // Performance Analytics Manager
  window.PerformanceAnalytics = {
    
    // Metrics collection
    metrics: {
      core_web_vitals: {},
      navigation_timing: {},
      resource_timing: [],
      user_timing: {},
      device_info: {},
      connection_info: {}
    },
    
    // Batch queue for analytics
    metricsBatch: [],
    
    // Initialize performance monitoring
    init: function() {\n      // Check if user consented to performance monitoring\n      if (!this.hasPerformanceConsent()) {\n        console.log('Performance monitoring disabled - no user consent');\n        return;\n      }\n      \n      this.collectDeviceInfo();\n      this.collectConnectionInfo();\n      this.monitorCoreWebVitals();\n      this.monitorNavigationTiming();\n      this.monitorResourceTiming();\n      this.setupPerformanceObserver();\n      this.setupReporting();\n      \n      console.log('Performance Analytics initialized');\n    },\n    \n    // Check if user consented to performance monitoring\n    hasPerformanceConsent: function() {\n      if (window.hasPerformanceConsent !== undefined) {\n        return window.hasPerformanceConsent;\n      }\n      \n      // Fallback: check consent management\n      if (window.ConsentManager) {\n        const consent = window.ConsentManager.getStoredConsent();\n        return consent && consent.preferences && consent.preferences.performance;\n      }\n      \n      return false; // Default to no consent\n    },\n    \n    // Collect device information\n    collectDeviceInfo: function() {\n      this.metrics.device_info = {\n        user_agent: navigator.userAgent,\n        language: navigator.language,\n        platform: navigator.platform,\n        screen_resolution: `${screen.width}x${screen.height}`,\n        viewport_size: `${window.innerWidth}x${window.innerHeight}`,\n        device_pixel_ratio: window.devicePixelRatio || 1,\n        hardware_concurrency: navigator.hardwareConcurrency || 'unknown',\n        device_memory: navigator.deviceMemory || 'unknown',\n        color_depth: screen.colorDepth,\n        timestamp: Date.now()\n      };\n    },\n    \n    // Collect connection information\n    collectConnectionInfo: function() {\n      const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;\n      \n      this.metrics.connection_info = {\n        effective_type: connection ? connection.effectiveType : 'unknown',\n        downlink: connection ? connection.downlink : 'unknown',\n        downlink_max: connection ? connection.downlinkMax : 'unknown',\n        rtt: connection ? connection.rtt : 'unknown',\n        save_data: connection ? connection.saveData : false,\n        timestamp: Date.now()\n      };\n    },\n    \n    // Monitor Core Web Vitals using web-vitals library pattern\n    monitorCoreWebVitals: function() {\n      // Largest Contentful Paint (LCP)\n      this.observeLCP();\n      \n      // First Input Delay (FID)\n      this.observeFID();\n      \n      // Cumulative Layout Shift (CLS)\n      this.observeCLS();\n      \n      // First Contentful Paint (FCP)\n      this.observeFCP();\n      \n      // Time to First Byte (TTFB)\n      this.observeTTFB();\n    },\n    \n    // Observe Largest Contentful Paint\n    observeLCP: function() {\n      if (!('PerformanceObserver' in window)) return;\n      \n      try {\n        const observer = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          const lastEntry = entries[entries.length - 1];\n          \n          this.metrics.core_web_vitals.lcp = {\n            value: lastEntry.startTime,\n            rating: this.getRating('lcp', lastEntry.startTime),\n            element: lastEntry.element ? lastEntry.element.tagName : 'unknown',\n            timestamp: Date.now()\n          };\n          \n          this.reportMetric('lcp', this.metrics.core_web_vitals.lcp);\n        });\n        \n        observer.observe({ entryTypes: ['largest-contentful-paint'] });\n      } catch (e) {\n        console.warn('LCP monitoring failed:', e);\n      }\n    },\n    \n    // Observe First Input Delay\n    observeFID: function() {\n      if (!('PerformanceObserver' in window)) return;\n      \n      try {\n        const observer = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          entries.forEach(entry => {\n            this.metrics.core_web_vitals.fid = {\n              value: entry.processingStart - entry.startTime,\n              rating: this.getRating('fid', entry.processingStart - entry.startTime),\n              event_type: entry.name,\n              timestamp: Date.now()\n            };\n            \n            this.reportMetric('fid', this.metrics.core_web_vitals.fid);\n          });\n        });\n        \n        observer.observe({ entryTypes: ['first-input'] });\n      } catch (e) {\n        console.warn('FID monitoring failed:', e);\n      }\n    },\n    \n    // Observe Cumulative Layout Shift\n    observeCLS: function() {\n      if (!('PerformanceObserver' in window)) return;\n      \n      let clsValue = 0;\n      let sessionValue = 0;\n      let sessionEntries = [];\n      \n      try {\n        const observer = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          \n          entries.forEach(entry => {\n            if (!entry.hadRecentInput) {\n              const firstSessionEntry = sessionEntries[0];\n              const lastSessionEntry = sessionEntries[sessionEntries.length - 1];\n              \n              if (sessionValue && entry.startTime - lastSessionEntry.startTime < 1000 && \n                  entry.startTime - firstSessionEntry.startTime < 5000) {\n                sessionValue += entry.value;\n                sessionEntries.push(entry);\n              } else {\n                sessionValue = entry.value;\n                sessionEntries = [entry];\n              }\n              \n              if (sessionValue > clsValue) {\n                clsValue = sessionValue;\n                \n                this.metrics.core_web_vitals.cls = {\n                  value: clsValue,\n                  rating: this.getRating('cls', clsValue),\n                  timestamp: Date.now()\n                };\n              }\n            }\n          });\n        });\n        \n        observer.observe({ entryTypes: ['layout-shift'] });\n        \n        // Report final CLS on page unload\n        addEventListener('beforeunload', () => {\n          if (this.metrics.core_web_vitals.cls) {\n            this.reportMetric('cls', this.metrics.core_web_vitals.cls);\n          }\n        });\n      } catch (e) {\n        console.warn('CLS monitoring failed:', e);\n      }\n    },\n    \n    // Observe First Contentful Paint\n    observeFCP: function() {\n      if (!('PerformanceObserver' in window)) return;\n      \n      try {\n        const observer = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          entries.forEach(entry => {\n            if (entry.name === 'first-contentful-paint') {\n              this.metrics.core_web_vitals.fcp = {\n                value: entry.startTime,\n                rating: this.getRating('fcp', entry.startTime),\n                timestamp: Date.now()\n              };\n              \n              this.reportMetric('fcp', this.metrics.core_web_vitals.fcp);\n            }\n          });\n        });\n        \n        observer.observe({ entryTypes: ['paint'] });\n      } catch (e) {\n        console.warn('FCP monitoring failed:', e);\n      }\n    },\n    \n    // Observe Time to First Byte\n    observeTTFB: function() {\n      addEventListener('load', () => {\n        const navTiming = performance.getEntriesByType('navigation')[0];\n        if (navTiming) {\n          const ttfb = navTiming.responseStart - navTiming.requestStart;\n          \n          this.metrics.core_web_vitals.ttfb = {\n            value: ttfb,\n            rating: this.getRating('ttfb', ttfb),\n            timestamp: Date.now()\n          };\n          \n          this.reportMetric('ttfb', this.metrics.core_web_vitals.ttfb);\n        }\n      });\n    },\n    \n    // Monitor navigation timing\n    monitorNavigationTiming: function() {\n      addEventListener('load', () => {\n        const navTiming = performance.getEntriesByType('navigation')[0];\n        if (!navTiming) return;\n        \n        this.metrics.navigation_timing = {\n          dns_lookup: navTiming.domainLookupEnd - navTiming.domainLookupStart,\n          tcp_connection: navTiming.connectEnd - navTiming.connectStart,\n          ssl_negotiation: navTiming.secureConnectionStart > 0 ? \n            navTiming.connectEnd - navTiming.secureConnectionStart : 0,\n          request_response: navTiming.responseEnd - navTiming.requestStart,\n          dom_processing: navTiming.domContentLoadedEventStart - navTiming.responseEnd,\n          load_complete: navTiming.loadEventEnd - navTiming.loadEventStart,\n          total_load_time: navTiming.loadEventEnd - navTiming.navigationStart,\n          timestamp: Date.now()\n        };\n        \n        this.reportMetric('navigation_timing', this.metrics.navigation_timing);\n      });\n    },\n    \n    // Monitor resource timing\n    monitorResourceTiming: function() {\n      if (!('PerformanceObserver' in window)) return;\n      \n      try {\n        const observer = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          \n          entries.forEach(entry => {\n            // Focus on critical resources\n            if (this.isCriticalResource(entry.name)) {\n              const resourceMetric = {\n                name: entry.name,\n                type: this.getResourceType(entry.name),\n                size: entry.transferSize || 0,\n                duration: entry.duration,\n                start_time: entry.startTime,\n                timestamp: Date.now()\n              };\n              \n              this.metrics.resource_timing.push(resourceMetric);\n              \n              // Report slow resources immediately\n              if (entry.duration > 1000) { // > 1 second\n                this.reportMetric('slow_resource', resourceMetric);\n              }\n            }\n          });\n        });\n        \n        observer.observe({ entryTypes: ['resource'] });\n      } catch (e) {\n        console.warn('Resource timing monitoring failed:', e);\n      }\n    },\n    \n    // Setup Performance Observer for user timing\n    setupPerformanceObserver: function() {\n      if (!('PerformanceObserver' in window)) return;\n      \n      try {\n        const observer = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          \n          entries.forEach(entry => {\n            if (entry.entryType === 'measure') {\n              this.metrics.user_timing[entry.name] = {\n                duration: entry.duration,\n                timestamp: Date.now()\n              };\n            }\n          });\n        });\n        \n        observer.observe({ entryTypes: ['measure'] });\n      } catch (e) {\n        console.warn('User timing monitoring failed:', e);\n      }\n    },\n    \n    // Setup periodic reporting\n    setupReporting: function() {\n      // Report metrics on page unload\n      addEventListener('beforeunload', () => {\n        this.flushMetrics();\n      });\n      \n      // Periodic reporting\n      setInterval(() => {\n        if (this.metricsBatch.length >= PERF_CONFIG.batch_size) {\n          this.flushMetrics();\n        }\n      }, PERF_CONFIG.report_interval);\n    },\n    \n    // Get performance rating\n    getRating: function(metric, value) {\n      const thresholds = PERF_CONFIG.thresholds[metric];\n      if (!thresholds) return 'unknown';\n      \n      if (value <= thresholds.good) return 'good';\n      if (value <= thresholds.needs_improvement) return 'needs-improvement';\n      return 'poor';\n    },\n    \n    // Check if resource is critical\n    isCriticalResource: function(url) {\n      // CSS, JS, fonts, and images from the same origin\n      return url.includes(window.location.origin) && \n             (url.match(/\\.(css|js|woff|woff2|ttf|png|jpg|jpeg|webp)$/i));\n    },\n    \n    // Get resource type from URL\n    getResourceType: function(url) {\n      if (url.match(/\\.(css)$/i)) return 'stylesheet';\n      if (url.match(/\\.(js)$/i)) return 'script';\n      if (url.match(/\\.(woff|woff2|ttf)$/i)) return 'font';\n      if (url.match(/\\.(png|jpg|jpeg|webp|gif|svg)$/i)) return 'image';\n      return 'other';\n    },\n    \n    // Report individual metric\n    reportMetric: function(metricName, metricData) {\n      // Add to batch queue\n      this.metricsBatch.push({\n        metric_name: metricName,\n        metric_data: metricData,\n        page_url: window.location.href,\n        user_agent: navigator.userAgent,\n        timestamp: Date.now()\n      });\n      \n      // Also send to Google Analytics if available\n      if (window.gtag) {\n        gtag('event', 'web_vital', {\n          'event_category': 'performance',\n          'metric_name': metricName,\n          'metric_value': metricData.value,\n          'metric_rating': metricData.rating,\n          'non_interaction': true\n        });\n      }\n    },\n    \n    // Flush metrics batch\n    flushMetrics: function() {\n      if (this.metricsBatch.length === 0) return;\n      \n      // Send to analytics endpoint (if you have one)\n      // For now, we'll just log and send to GA\n      console.log('Performance Metrics Batch:', this.metricsBatch);\n      \n      // Send batch to Google Analytics\n      if (window.gtag) {\n        gtag('event', 'performance_batch', {\n          'event_category': 'performance',\n          'batch_size': this.metricsBatch.length,\n          'device_memory': this.metrics.device_info.device_memory,\n          'connection_type': this.metrics.connection_info.effective_type,\n          'non_interaction': true\n        });\n      }\n      \n      // Clear batch\n      this.metricsBatch = [];\n    },\n    \n    // Public API for custom performance marks\n    mark: function(name) {\n      if ('performance' in window && performance.mark) {\n        performance.mark(name);\n      }\n    },\n    \n    // Public API for custom performance measures\n    measure: function(name, startMark, endMark) {\n      if ('performance' in window && performance.measure) {\n        try {\n          performance.measure(name, startMark, endMark);\n        } catch (e) {\n          console.warn('Performance measure failed:', e);\n        }\n      }\n    },\n    \n    // Get current performance summary\n    getPerformanceSummary: function() {\n      return {\n        core_web_vitals: this.metrics.core_web_vitals,\n        navigation_timing: this.metrics.navigation_timing,\n        device_info: this.metrics.device_info,\n        connection_info: this.metrics.connection_info,\n        resource_count: this.metrics.resource_timing.length\n      };\n    }\n  };\n  \n  // Initialize when DOM is ready\n  document.addEventListener('DOMContentLoaded', function() {\n    // Wait for consent management to be ready\n    setTimeout(() => {\n      window.PerformanceAnalytics.init();\n    }, 1000);\n  });\n  \n  // Custom performance marks for blog-specific metrics\n  document.addEventListener('DOMContentLoaded', function() {\n    window.PerformanceAnalytics.mark('blog-dom-ready');\n  });\n  \n  window.addEventListener('load', function() {\n    window.PerformanceAnalytics.mark('blog-load-complete');\n    window.PerformanceAnalytics.measure('blog-total-load', 'navigationStart', 'blog-load-complete');\n  });\n  \n})();\n</script>"