---
export interface Props {
  showInHeader?: boolean;
  showFloating?: boolean;
  estimatedReadTime?: number;
}

const { showInHeader = true, showFloating = false, estimatedReadTime } = Astro.props;
---

<!-- Header Progress Bar -->
{showInHeader && (
  <div class="reading-progress-header fixed top-0 left-0 right-0 z-50 pointer-events-none">
    <div class="progress-track h-1 bg-gray-200/50 dark:bg-gray-700/50 backdrop-blur-sm">
      <div class="progress-bar h-full bg-gradient-to-r from-primary-500 to-primary-600 transition-all duration-200 ease-out" style="width: 0%"></div>
    </div>
  </div>
)}

<!-- Floating Progress Indicator -->
{showFloating && (
  <div class="reading-progress-floating fixed bottom-8 right-8 z-40 opacity-0 pointer-events-none transition-all duration-300">
    <div class="progress-circle relative w-16 h-16 bg-white dark:bg-gray-800 rounded-full shadow-lg border border-gray-200 dark:border-gray-700">
      <!-- Circular Progress -->
      <svg class="progress-ring absolute inset-0 w-full h-full transform -rotate-90" viewBox="0 0 64 64">
        <circle 
          class="progress-ring-track" 
          cx="32" 
          cy="32" 
          r="28" 
          fill="none" 
          stroke="currentColor" 
          stroke-width="4" 
          class="text-gray-200 dark:text-gray-600"
        />
        <circle 
          class="progress-ring-fill" 
          cx="32" 
          cy="32" 
          r="28" 
          fill="none" 
          stroke="currentColor" 
          stroke-width="4" 
          stroke-linecap="round" 
          class="text-primary-500"
          style="stroke-dasharray: 175.929; stroke-dashoffset: 175.929; transition: stroke-dashoffset 0.3s ease;"
        />
      </svg>
      
      <!-- Progress Percentage -->
      <div class="absolute inset-0 flex items-center justify-center">
        <span class="progress-percentage text-xs font-bold text-gray-700 dark:text-gray-300">0%</span>
      </div>
      
      <!-- Reading Time Indicator -->
      {estimatedReadTime && (
        <div class="progress-time absolute -top-8 left-1/2 transform -translate-x-1/2 bg-gray-900 dark:bg-gray-100 text-white dark:text-gray-900 px-2 py-1 rounded text-xs font-medium opacity-0 transition-opacity whitespace-nowrap">
          <span class="time-remaining">{estimatedReadTime}</span>min left
          <div class="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900 dark:border-t-gray-100"></div>
        </div>
      )}
    </div>
  </div>
)}

<style>
  .reading-progress-header {
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
  }

  .reading-progress-floating.visible {
    opacity: 1;
    pointer-events: auto;
  }

  .reading-progress-floating:hover .progress-time {
    opacity: 1;
  }

  .progress-circle {
    transition: transform 0.2s ease;
  }

  .reading-progress-floating:hover .progress-circle {
    transform: scale(1.1);
  }

  /* Pulse animation for milestones */
  .milestone-pulse {
    animation: pulse-milestone 0.6s ease-out;
  }

  @keyframes pulse-milestone {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
  }

  /* Mobile adjustments */
  @media (max-width: 768px) {
    .reading-progress-floating {
      bottom: 6rem; /* Above mobile navigation */
      right: 1rem;
      width: 3rem;
      height: 3rem;
    }

    .progress-circle {
      width: 3rem;
      height: 3rem;
    }

    .progress-percentage {
      font-size: 0.625rem;
    }

    .progress-time {
      display: none; /* Hide on mobile to save space */
    }
  }
</style>

<script>
  interface ReadingProgressOptions {
    headerSelector?: string;
    floatingSelector?: string;
    contentSelector?: string;
    estimatedReadTime?: number;
  }

  class ReadingProgressTracker {
    private headerProgress: HTMLElement | null = null;
    private floatingProgress: HTMLElement | null = null;
    private content: HTMLElement | null = null;
    private progressBar: HTMLElement | null = null;
    private progressRing: SVGCircleElement | null = null;
    private progressPercentage: HTMLElement | null = null;
    private timeRemaining: HTMLElement | null = null;
    private estimatedReadTime: number = 0;
    private circumference: number = 175.929; // 2 * Ï€ * 28
    private milestones: Set<number> = new Set([25, 50, 75, 100]);
    private triggeredMilestones: Set<number> = new Set();

    constructor(options: ReadingProgressOptions = {}) {
      this.headerProgress = document.querySelector(options.headerSelector || '.reading-progress-header');
      this.floatingProgress = document.querySelector(options.floatingSelector || '.reading-progress-floating');
      this.content = document.querySelector(options.contentSelector || 'main, article, .prose');
      this.estimatedReadTime = options.estimatedReadTime || 0;

      if (this.headerProgress) {
        this.progressBar = this.headerProgress.querySelector('.progress-bar');
      }

      if (this.floatingProgress) {
        this.progressRing = this.floatingProgress.querySelector('.progress-ring-fill');
        this.progressPercentage = this.floatingProgress.querySelector('.progress-percentage');
        this.timeRemaining = this.floatingProgress.querySelector('.time-remaining');
      }

      this.init();
    }

    private init(): void {
      if (!this.content) return;

      this.handleScroll = this.handleScroll.bind(this);
      window.addEventListener('scroll', this.handleScroll, { passive: true });
      
      // Initial calculation
      this.handleScroll();
    }

    private handleScroll(): void {
      const progress = this.calculateProgress();
      this.updateProgress(progress);
      this.updateVisibility(progress);
      this.checkMilestones(progress);
    }

    private calculateProgress(): number {
      if (!this.content) return 0;

      const rect = this.content.getBoundingClientRect();
      const contentHeight = this.content.scrollHeight;
      const viewportHeight = window.innerHeight;
      const scrollTop = window.pageYOffset;
      const contentTop = scrollTop + rect.top;
      
      // Calculate readable content area (excluding header/footer)
      const readableStart = contentTop;
      const readableHeight = contentHeight - viewportHeight;
      const currentScroll = scrollTop - readableStart;
      
      if (readableHeight <= 0) return 0;
      
      const progress = Math.max(0, Math.min(100, (currentScroll / readableHeight) * 100));
      return progress;
    }

    private updateProgress(progress: number): void {
      // Update header progress bar
      if (this.progressBar) {
        this.progressBar.style.width = `${progress}%`;
      }

      // Update floating circular progress
      if (this.progressRing) {
        const offset = this.circumference - (progress / 100) * this.circumference;
        this.progressRing.style.strokeDashoffset = offset.toString();
      }

      if (this.progressPercentage) {
        this.progressPercentage.textContent = `${Math.round(progress)}%`;
      }

      // Update time remaining
      if (this.timeRemaining && this.estimatedReadTime > 0) {
        const remainingTime = Math.max(0, Math.ceil(this.estimatedReadTime * (1 - progress / 100)));
        this.timeRemaining.textContent = remainingTime.toString();
      }
    }

    private updateVisibility(progress: number): void {
      if (!this.floatingProgress) return;

      // Show floating progress after 10% and hide when near 100%
      const shouldShow = progress > 10 && progress < 95;
      
      if (shouldShow) {
        this.floatingProgress.classList.add('visible');
      } else {
        this.floatingProgress.classList.remove('visible');
      }
    }

    private checkMilestones(progress: number): void {
      for (const milestone of this.milestones) {
        if (progress >= milestone && !this.triggeredMilestones.has(milestone)) {
          this.triggeredMilestones.add(milestone);
          this.triggerMilestone(milestone);
        }
      }
    }

    private triggerMilestone(milestone: number): void {
      // Add visual feedback for milestone
      if (this.floatingProgress) {
        this.floatingProgress.classList.add('milestone-pulse');
        setTimeout(() => {
          this.floatingProgress?.classList.remove('milestone-pulse');
        }, 600);
      }

      // Haptic feedback on supported devices
      if ('vibrate' in navigator) {
        navigator.vibrate(50);
      }

      // Custom event for tracking
      window.dispatchEvent(new CustomEvent('reading-milestone', {
        detail: { milestone, progress: milestone }
      }));
    }

    public destroy(): void {
      window.removeEventListener('scroll', this.handleScroll);
    }
  }

  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    // Get estimated read time from meta tag or reading time component
    const readTimeElement = document.querySelector('[data-read-time]');
    const estimatedTime = readTimeElement ? 
      parseInt(readTimeElement.getAttribute('data-read-time') || '0') : 0;

    new ReadingProgressTracker({
      estimatedReadTime: estimatedTime
    });
  });

  // Analytics integration
  window.addEventListener('reading-milestone', (event: Event) => {
    const customEvent = event as CustomEvent;
    const { milestone } = customEvent.detail;
    
    // Google Analytics 4
    if (typeof gtag !== 'undefined') {
      gtag('event', 'reading_progress', {
        milestone: milestone,
        page_title: document.title,
        page_location: window.location.href
      });
    }
  });
</script>