---
title: "AI 멀티플렉싱 워크플로우: ADHD급 생산성 향상기 (4편) - 도구별 프롬프트 전략"
description: "Cursor Pro, Claude Code, Gemini CLI 각각에 최적화된 실전 프롬프트 노하우 대공개"
pubDate: 2025-07-27
heroImage: "/assets/img/ai-workflow.jpg"
categories: ["Tech", "AI"]
tags: ["AI", "Productivity", "Prompt", "Cursor", "Claude", "Gemini", "ChatGPT"]
lang: "ko"
author: "Jay Lee"
readingTime: "10분"
---

![AI Prompt Strategies](/assets/img/ai-workflow.jpg)

# AI 멀티플렉싱 워크플로우: ADHD급 생산성 향상기 (4편)
## 도구별 프롬프트 전략

안녕하세요! 시리즈도 벌써 4편이네요. [1편](./2025-07-24-ai-workflow-productivity.md)에서 AI 스택을, [2편](./2025-07-25-ai-workflow-common-methods.md)에서 공통 워크플로우를, [3편](./2025-07-26-ai-workspace-management.md)에서 워크스페이스 운영을 다뤘다면, 이번에는 **각 AI 도구별로 최적화된 프롬프트 전략**을 공개합니다!

이건 진짜 **몇 개월간 시행착오**를 거쳐서 정리한 것들이라, 바로 써먹으실 수 있을 거예요. 각 도구의 특성에 맞는 프롬프트 패턴들을 실제 예시와 함께 공유해드릴게요!

## Cursor Pro: 메인 코딩 환경 마스터하기

### Cursor의 특성 이해하기

**Cursor는 코드 컨텍스트를 가장 잘 이해하는** AI 도구입니다. 파일 전체를 보면서 작업하기 때문에, 다른 도구들과는 다른 접근이 필요해요.

### Cursor 특화 프롬프트 패턴

#### 1. 프로젝트 전체 맥락 활용 패턴

**❌ 비효율적인 방식:**
```
이 함수 리팩토링해줘

function getUserData(id: string) {  // 복잡한 로직...
}
```

**✅ Cursor 최적화 방식:**
```
현재 프로젝트의 TypeScript 타입 정의와 에러 핸들링 패턴을 참고해서,
이 getUserData 함수를 프로젝트 표준에 맞게 리팩토링해줘.

특히 다음을 고려해서:
1. src/types/ 폴더의 User 타입 정의 활용
2. src/utils/errorHandler.ts의 에러 처리 패턴 적용  3. 다른 service 파일들과 일관된 구조로 변경

@getUserData 함수 위치 표시
```

#### 2. 파일 간 연관성 활용 패턴

**실제 제가 쓰는 프롬프트:**
```
@src/services/userService.ts
@src/types/User.ts
@src/utils/apiClient.ts

위 파일들의 패턴을 참고해서 새로운 productService.ts를 만들어줘.

요구사항:
- User 관련 코드와 동일한 구조
- 같은 에러 핸들링 방식
- apiClient 활용 패턴 동일하게 적용
- TypeScript 타입 안정성 최우선

Product 타입은 다음과 같아:
interface Product {  id: string;  name: string;  price: number;  // ... 기타 필드
}
```

#### 3. 코드 리뷰 및 개선 패턴

**제가 자주 쓰는 코드 리뷰 프롬프트:**
```
@선택된_파일_또는_코드

프로젝트의 다른 파일들과 비교해서 이 코드를 리뷰해줘.

리뷰 관점:
1. 🔍 **일관성**: 프로젝트 내 다른 코드와 패턴이 일치하는가?
2. 🏗️ **아키텍처**: 전체 구조에 잘 맞는가?
3. 🔒 **타입 안정성**: TypeScript 활용이 충분한가?
4. 🚀 **성능**: 최적화할 부분이 있는가?
5. 🧪 **테스트**: 테스트하기 쉬운 구조인가?

각 항목별로 구체적인 개선사항과 이유를 제시해줘.
```

### Cursor Chat vs Inline Edit 활용법

#### Chat에서 쓰는 프롬프트 (복잡한 설계)

```
프로젝트 전체 구조를 고려해서 새로운 기능을 설계해보자.

**기능**: 사용자 권한 관리 시스템
**요구사항**: 
- 역할 기반 접근 제어 (RBAC)
- 기존 User 시스템과 통합
- API 엔드포인트별 권한 체크

현재 프로젝트 구조에서 이 기능을 어떻게 통합할지 설계안을 제시해줘:
1. 파일 구조 제안
2. 기존 코드 수정점
3. 새로 만들 컴포넌트들
4. 데이터베이스 스키마 변경사항
```

#### Inline Edit에서 쓰는 프롬프트 (구체적 수정)

```
// Cmd+K로 Inline Edit 모드에서
이 함수를 async/await 패턴으로 변경하고, 
프로젝트의 에러 핸들링 표준에 맞게 try-catch 추가해줘
```

## 🟣 Claude Code: 3시간 제한 극복 전략

### Claude Code의 특성과 한계

**3시간마다 Usage 리셋**되는 Claude Code... 비싸게 주고도 이런 제약이 있어서 진짜 전략적으로 써야 해요.  ### Usage 효율성 극대화 패턴

#### 1. 한 번에 최대한 많이 뽑아내기

**❌ 비효율적 (Usage 낭비):**
```
대화 1: "이 함수 리팩토링해줘"
대화 2: "아 그리고 테스트 코드도 만들어줘" 
대화 3: "문서화도 해줘"
대화 4: "타입 정의도 개선해줘"
```

**✅ 효율적 (한 번에 해결):**
```
다음 작업을 한 번에 모두 처리해줘:

**대상**: UserService 클래스 전체 개선
**Context**: TypeScript + NestJS 백엔드 프로젝트

**요청사항 (한 번에 모두):**
1. 🔧 리팩토링: 함수별 단일 책임 원칙 적용
2. 🧪 테스트: Jest 기반 유닛 테스트 작성  3. 📝 문서화: JSDoc + README 업데이트
4. 🔒 타입: 더 엄격한 TypeScript 타입 정의
5. 🚀 성능: 불필요한 DB 쿼리 최적화

모든 결과물을 단계별로 정리해서 한 번에 제공해줘.
```

#### 2. 복잡한 로직은 Claude Code에 몰아주기

**Claude Code가 특히 잘하는 것들:**
- **복잡한 비즈니스 로직** 설계
- ️ **아키텍처 설계** 및 패턴 적용  - **코드 리뷰** 및 품질 분석
- **문서화** 및 가이드 작성

**실제 제가 Claude Code에 맡기는 작업:**
```
마이크로서비스 간 통신을 위한 Event-Driven Architecture를 설계해줘.

**현재 상황:**
- 5개의 독립 서비스 (User, Product, Order, Payment, Notification)
- 각각 별도 DB 및 API
- 서비스 간 RESTful API로 동기 통신 중

**목표:**
- 비동기 이벤트 기반 통신으로 전환
- 장애 복구 및 재시도 로직 포함
- 모니터링 및 로깅 체계 구축

**결과물:**
1. 📋 전체 아키텍처 다이어그램 (Mermaid)
2. 🔧 구현 예시 코드 (TypeScript + Node.js)
3. 📝 Migration 가이드
4. 🧪 테스트 전략
5. 📊 모니터링 방안

한 번에 완전한 설계안을 제공해줘.
```

#### 3. 시간대별 전략적 사용

**제가 쓰는 Claude Code 시간 관리:**
```
오전 (9-12시): 새로운 기능 설계
- 복잡한 아키텍처 설계
- 새 프로젝트 구조 설계

오후 (13-15시): 기존 코드 개선  - 레거시 코드 리팩토링
- 성능 최적화

저녁 (18-20시): 문서화 및 정리
- API 문서 자동 생성
- 프로젝트 가이드 작성
```

### Claude Code 전용 프롬프트 템플릿

```markdown
# Claude Code 전용 대화 시작 템플릿

## 프로젝트 Context
- **기술 스택**: [상세 기술 스택]
- **프로젝트 규모**: [팀 규모, 코드 라인 수 등]
- **현재 상황**: [해결하려는 문제]
- **목표**: [달성하려는 결과]

## 이번 세션 목표
- [ ] 주요 작업 1
- [ ] 주요 작업 2  - [ ] 주요 작업 3

## 제약사항
- 기존 API 호환성 유지
- 특정 라이브러리 사용 필수
- 성능 요구사항: [구체적 수치]

## 원하는 결과물 형태
1. 📋 설계 문서 (아키텍처 다이어그램 포함)
2. 🔧 구현 코드 (주석 포함)
3. 🧪 테스트 코드
4. 📝 사용 가이드

---
[구체적 요청 시작]
```

## Gemini CLI: 문서화 자동화 마스터

### Gemini의 강력한 문서화 능력

**진짜 Gemini 2.5 Pro는 문서화가 기똥차요.** 특히 CLI에서 쓰면 더 편합니다.

### Gemini CLI 설치 및 설정

```bash
# Gemini CLI 설치
npm install -g @google/generative-ai-cli

# API 키 설정
export GEMINI_API_KEY="your-api-key"

# 또는 ~/.bashrc에 추가
echo 'export GEMINI_API_KEY="your-api-key"' >> ~/.bashrc
```

### 문서화 특화 프롬프트 패턴

#### 1. API 문서 자동 생성

**실제 제가 쓰는 명령어:**
```bash
# 코드 파일을 분석해서 API 문서 생성
gemini "
다음 TypeScript 코드를 분석해서 완전한 API 문서를 생성해줘:

$(cat src/controllers/userController.ts)

**생성할 문서 형태:**
1. 📋 엔드포인트 개요 테이블
2. 🔧 각 엔드포인트 상세 (Request/Response)
3. 📝 사용 예시 (curl + JavaScript)  4. ⚠️ 에러 응답 정의
5. 🔒 인증 요구사항

**포맷**: OpenAPI 3.0 spec + 한국어 설명
"
```

#### 2. README 자동 생성 및 업데이트

```bash
# 프로젝트 전체를 분석해서 README 생성
gemini "
다음 프로젝트 구조를 분석해서 전문적인 README.md를 생성해줘:

**프로젝트 구조:**
$(tree -I 'node_modules|.git' -L 3)

**package.json 정보:**  $(cat package.json)

**주요 설정 파일들:**
$(cat tsconfig.json)
$(cat .env.example)

**생성할 README 섹션:**
1. 🎯 프로젝트 개요 및 특징
2. ⚡ Quick Start 가이드  3. 🏗️ 아키텍처 설명
4. 🔧 설치 및 설정 방법
5. 📝 API 사용법
6. 🧪 테스트 실행 방법
7. 🚀 배포 가이드
8. 🤝 기여 방법

**톤**: 전문적이면서도 친근한 개발자 톤
"
```

#### 3. 코드 주석 및 문서화

```bash
# 복잡한 함수에 JSDoc 주석 자동 생성
gemini "
다음 TypeScript 함수에 완전한 JSDoc 주석을 달아줘:

$(cat src/utils/complexAlgorithm.ts)

**주석 요구사항:**
1. 📝 함수 목적 및 동작 원리 설명
2. 📋 모든 매개변수 타입 및 설명
3. 🔄 반환값 타입 및 설명  4. ⚠️ 발생 가능한 예외사항
5. 📖 사용 예시 코드
6. 🔗 관련 함수/문서 링크

**스타일**: JSDoc 표준 + 이모티콘으로 가독성 향상
"
```

### Gemini CLI 자동화 스크립트

**docs-update.sh:**
```bash
#!/bin/bash

echo "📝 자동 문서화 시작..."

# 1. API 문서 업데이트
echo "🔧 API 문서 생성 중..."
gemini "
$(cat src/controllers/*.ts | head -200)

위 컨트롤러들을 분석해서 docs/api.md를 업데이트해줘.
변경된 엔드포인트만 반영하고, 기존 문서 구조는 유지해줘.
" > docs/api-temp.md

# 2. README 업데이트  echo "📋 README 업데이트 중..."
gemini "
현재 README.md:
$(cat README.md)

최신 package.json:
$(cat package.json)

README를 최신 정보로 업데이트해줘. 
기존 톤은 유지하되, 변경된 dependencies나 scripts 정보만 반영해줘.
" > README-temp.md

# 3. 변경사항 검토 후 적용
echo "📊 문서 변경사항 검토..."
echo "API 문서 변경사항:"
diff docs/api.md docs/api-temp.md || true

echo "README 변경사항:"  diff README.md README-temp.md || true

read -p "변경사항을 적용하시겠습니까? (y/n): " confirm
if [ "$confirm" = "y" ]; then  mv docs/api-temp.md docs/api.md  mv README-temp.md README.md  echo "✅ 문서 업데이트 완료"
else  rm docs/api-temp.md README-temp.md  echo "❌ 변경사항 취소됨"
fi
```

## 🟢 ChatGPT Pro: 감정노동 전문가

### ChatGPT의 독특한 강점

**고객 대응이나 이메일 작성**에서 ChatGPT만큼 좋은 게 없어요. 감정적인 뉘앙스를 잘 이해하고 적절한 톤으로 응답해줍니다.

### 비즈니스 커뮤니케이션 프롬프트

#### 1. 고객 이메일 응답

**실제 제가 쓰는 패턴:**
```
다음 상황에서 고객에게 보낼 이메일을 작성해줘:

**상황**: 
- 고객이 API 응답 속도 이슈로 불만 제기
- 실제로 일시적인 서버 과부하가 있었음
- 현재는 해결된 상태
- 재발 방지책도 마련됨

**고객 톤**: 약간 화난 상태, 비즈니스 파트너
**원하는 응답 톤**: 사과하되 전문적, 해결책 중심

**포함할 내용**:
1. 🙏 상황 인정 및 사과
2. 🔍 원인 설명 (기술적이지만 이해하기 쉽게)
3. ✅ 해결 완료 확인
4. 🛡️ 재발 방지책 설명
5. 📞 추가 지원 안내

**이메일 길이**: 간결하게 3-4 문단
```

#### 2. 내부 커뮤니케이션

```
팀 내부 회의록을 정리해줘:

**회의 내용** (음성녹음 → 텍스트):
[복잡하고 정리되지 않은 회의 내용들...]

**정리 요구사항**:
1. 📋 주요 논의사항 (우선순위별)
2. ✅ 결정된 사항들
3. 📋 액션 아이템 (담당자, 마감일 포함)  4. ❓ 추후 논의 필요 사항
5. 📅 다음 미팅 일정

**톤**: 팀 내부용, 간결하고 명확하게
```

## 도구 간 연계 활용 패턴

### 협업 워크플로우

실제로는 **도구들을 연계해서** 쓸 때 가장 효과적입니다.

#### 패턴 1: 설계 → 구현 → 문서화

```
1. 🟣 Claude Code: 전체 아키텍처 설계  "마이크로서비스 아키텍처 설계해줘"

2. 🔵 Cursor Pro: 실제 코드 구현  "Claude가 설계한 구조를 바탕으로 UserService 구현"

3. 🔴 Gemini CLI: 문서화  "구현된 코드를 분석해서 API 문서 생성"

4. 🟢 ChatGPT: 사용자 가이드  "기술 문서를 일반 사용자용 가이드로 변환"
```

#### 패턴 2: 문제 해결 → 소통 → 정리

```
1. 🔵 Cursor Pro: 버그 분석 및 수정  "이 에러 로그 분석해서 원인 찾고 수정해줘"

2. 🟢 ChatGPT: 고객 응답 작성  "버그 수정 완료를 고객에게 알리는 이메일 작성"

3. 🔴 Gemini CLI: 포스트모템 문서  "이번 이슈의 포스트모템 문서 작성"
```

## 효과 측정 및 개선

### 프롬프트 성능 추적

**제가 쓰는 간단한 평가 기준:**

```markdown
## 프롬프트 평가 기준

각 응답에 대해 1-5점으로 평가:

1. **정확성** (1-5): 요청한 내용을 정확히 수행했는가?
2. **완성도** (1-5): 추가 요청 없이 바로 사용 가능한가?  3. **효율성** (1-5): 최소한의 프롬프트로 최대 결과를 얻었는가?
4. **일관성** (1-5): 비슷한 요청에서 일관된 품질인가?

**목표**: 모든 항목 평균 4점 이상 유지
```

### 지속적인 프롬프트 개선

**월간 리뷰 프로세스:**
1. **사용 빈도** 높은 프롬프트 패턴 정리
2. **실패 사례** 분석 및 개선 방안 도출  3. **새로운 패턴** 실험 및 검증
4. **팀 공유** 및 피드백 수집

## 마무리하며...

이렇게 **각 AI 도구별로 최적화된 프롬프트 전략**을 정리해봤습니다.  핵심은 **각 도구의 특성을 이해하고 그에 맞는 프롬프트를 쓰는 것**입니다. Cursor는 코드 컨텍스트를, Claude는 복잡한 사고를, Gemini는 문서화를, ChatGPT는 커뮤니케이션을 각각 잘하니까요.

마지막 5편에서는 **PRD 방법론으로 새 프로젝트 시작하기**를 다뤄보겠습니다. Gemini로 Research를 돌려서 들쭉날쭉한 AI를 더 잘하게 만드는 PRD 작성법과 실제 적용 사례를 공유할 예정입니다!

여러분은 어떤 프롬프트 패턴을 사용하고 계신가요? 특히 잘 되는 패턴이 있으면 댓글로 공유해주세요!

---

*이 시리즈의 다른 글들:*
- *[1편: AI 스택 소개와 전체 개요](./2025-07-24-ai-workflow-productivity.md)*
- *[2편: 공통 워크플로우 방법론](./2025-07-25-ai-workflow-common-methods.md)*
- *[3편: 워크스페이스 운영 실전기](./2025-07-26-ai-workspace-management.md)*
- *5편: PRD 방법론으로 새 프로젝트 시작하기 (곧 공개)* 