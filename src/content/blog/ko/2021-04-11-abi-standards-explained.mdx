---
title: "ABI 표준 설명"
author: "Jay Lee"
pubDate: "2021-04-11 00:00:00"
categories: ["TechSavvy", "ComputerArchitecture"]
tags: ["Blogging", "ComputerArchitecture", "Linux", "AGL", "EmbeddedLinux", "OpenEmbedded", "Yocto", "CrossDevelopment", "GCC", "GDB", "Toolchain"]
---

## ABI (Application Binary Interface) 표준

ABI는 애플리케이션이 이진 데이터를 교환하는 방법에 대한 다음과 같은 규칙을 정의합니다:

- 데이터 타입 및 정렬 방법
- 함수 호출 인수 및 결과를 위한 레지스터 교환 방법
- 시스템 콜 호출 방법
- 프로그램 코드 초기화 및 데이터 초기화 방법
- 파일 교환 방법 (ELF 등)

### EABI 표준

EABI (Embedded ABI)는 임베디드 환경을 위한 ABI를 다룹니다. ARM 아키텍처에서 ABI 사용 방법은 Linux 버전에 따라 다르며, 다음 두 가지 접근 방식으로 나뉩니다:

- arm/OABI
    - 커널 v2.6.15 이전 (메인라인 v2.6.16)에서 사용된 ABI 방법 (Old ABI 또는 legacy ABI라고도 함)
    - glibc 2.3.6까지 사용
    - gcc: linux-arm-none-gnu
- arm/EABI
    - 커널 v2.6.16부터 사용된 ARM EABI 방법
    - glibc v2.3.7 및 v2.4부터 사용
    - gcc: linux-arm-none-gnueabi

## arm/OABI와 arm/EABI의 차이점

### 소프트웨어 인터럽트 호출 방법

- OABI
    - swi __NR_SYSCALL_BASE(==0x900000)+1
- EABI
    - mov r7, #1 (시스템 콜 인덱스)
    - swi 0

### 구조체 패킹

- OABI
    - 구조체는 4바이트 단위로 정렬됨
- EABI
    - 구조체 크기를 그대로 사용

### 스택 인수 정렬

- OABI
    - 스택에 저장할 때 4바이트 단위로 저장
- EABI
    - 스택에 저장할 때 8바이트 단위로 저장

### 64비트 타입 인수 정렬

- OABI
    - 4바이트 단위로 정렬
- EABI
    - 8바이트 단위로 정렬

### Enum 타입 크기

- OABI
    - 4바이트 단위
- EABI
    - 가변으로 지정 가능

### 인수 전달을 위한 레지스터 수

- OABI
    - 4개 레지스터 (r0~r3)
- EABI
    - 7개 레지스터 (r0~r6)

## 차이점 예제

### 소프트웨어 인터럽트 + 64비트 타입 인수 정렬

예제: long sum64(unsigned int start, size_t size); syscall no=100

- arm/OABI
    - start를 r0에 할당
    - size를 64비트로 r1과 r2에 할당
    - swi #(0x900000 + 100)
- arm/EABI
    - start를 r0에 할당
    - size를 64비트로 r2와 r3에 할당
    - 100을 r7에 할당
    - swi 0